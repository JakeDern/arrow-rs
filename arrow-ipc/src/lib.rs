// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//! Support for the [Arrow IPC Format]
//!
//! The Arrow IPC format defines how to read and write [`RecordBatch`]es to/from
//! a file or stream of bytes. This format can be used to serialize and deserialize
//! data to files and over the network.
//!
//! There are two variants of the IPC format:
//! 1. [IPC Streaming Format]: Supports streaming data sources, implemented by
//!    [StreamReader] and [StreamWriter]
//!
//! 2. [IPC File Format]: Supports random access, implemented by [FileReader] and
//!    [FileWriter].
//!
//! See the [`reader`] and [`writer`] modules for more information.
//!
//! [Arrow IPC Format]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc
//! [IPC Streaming Format]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format
//! [StreamReader]: reader::StreamReader
//! [StreamWriter]: writer::StreamWriter
//! [IPC File Format]: https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format
//! [FileReader]: reader::FileReader
//! [FileWriter]: writer::FileWriter

#![doc(
    html_logo_url = "https://arrow.apache.org/img/arrow-logo_chevrons_black-txt_white-bg.svg",
    html_favicon_url = "https://arrow.apache.org/img/arrow-logo_chevrons_black-txt_transparent-bg.svg"
)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![warn(missing_docs)]
pub mod convert;
pub mod reader;
pub mod writer;

mod compression;

#[allow(clippy::redundant_closure)]
#[allow(clippy::needless_lifetimes)]
#[allow(clippy::extra_unused_lifetimes)]
#[allow(clippy::redundant_static_lifetimes)]
#[allow(clippy::redundant_field_names)]
#[allow(non_camel_case_types)]
#[allow(missing_docs)] // Because this is autogenerated
pub mod gen;

use std::collections::HashMap;
use std::io::Read;

use arrow_array::ArrayRef;
use arrow_buffer::MutableBuffer;
use arrow_schema::ArrowError;
use arrow_schema::SchemaRef;

pub use self::gen::File::*;
pub use self::gen::Message::*;
pub use self::gen::Schema::*;
pub use self::gen::SparseTensor::*;
pub use self::gen::Tensor::*;
use self::reader::RecordBatchDecoder;

const ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];
const CONTINUATION_MARKER: [u8; 4] = [0xff; 4];

impl Endianness {
    /// Returns true if the endianness of the source system matches the endianness of the target system.
    pub fn equals_to_target_endianness(self) -> bool {
        match self {
            Self::Little => cfg!(target_endian = "little"),
            Self::Big => cfg!(target_endian = "big"),
            _ => false,
        }
    }
}

pub(crate) enum IpcMessage<'a> {
    Schema(Message<'a>, Schema<'a>, arrow_schema::Schema),
    RecordBatch(Message<'a>, RecordBatch<'a>, MutableBuffer),
    DictionaryBatch(Message<'a>, DictionaryBatch<'a>, MutableBuffer),
}

pub(crate) struct IpcDecoder<R> {
    reader: R,
    meta_buf: Vec<u8>,
}

impl<R: Read> IpcDecoder<R> {
    pub fn new(reader: R) -> Self {
        Self {
            reader,
            meta_buf: Vec::new(),
        }
    }

    /// Gets a reference to the underlying reader.
    ///
    /// It is inadvisable to directly read from the underlying reader.
    pub fn get_ref(&self) -> &R {
        &self.reader
    }

    /// Gets a mutable reference to the underlying reader.
    ///
    /// It is inadvisable to directly read from the underlying reader.
    pub fn get_mut(&mut self) -> &mut R {
        &mut self.reader
    }

    pub fn read_message(&mut self) -> Result<IpcMessage, ArrowError> {
        let meta_len = self.read_meta_size()?;
        self.meta_buf.resize(meta_len as usize, 0);
        self.reader.read_exact(&mut self.meta_buf)?;

        let message = crate::root_as_message(self.meta_buf.as_slice()).map_err(|err| {
            ArrowError::ParseError(format!("Unable to get root as message: {err:?}"))
        })?;

        let ipc_message = match message.header_type() {
            MessageHeader::Schema => {
                let schema = message.header_as_schema().ok_or_else(|| {
                    ArrowError::ParseError("Failed to parse schema from message header".to_string())
                })?;
                let arrow_schema = crate::convert::fb_to_schema(schema);
                IpcMessage::Schema(message, schema, arrow_schema)
            }
            MessageHeader::RecordBatch => {
                let batch = message.header_as_record_batch().ok_or_else(|| {
                    ArrowError::IpcError("Unable to read IPC message as record batch".to_string())
                })?;

                let mut buf = MutableBuffer::from_len_zeroed(message.bodyLength() as usize);
                self.reader.read_exact(&mut buf)?;
                IpcMessage::RecordBatch(message, batch, buf)
            }
            MessageHeader::DictionaryBatch => {
                let dict = message.header_as_dictionary_batch().ok_or_else(|| {
                    ArrowError::ParseError(
                        "Failed to parse dictionary batch from message header".to_string(),
                    )
                })?;

                let mut buf = MutableBuffer::from_len_zeroed(message.bodyLength() as usize);
                self.reader.read_exact(&mut buf)?;
                IpcMessage::DictionaryBatch(message, dict, buf)
            }
            x => {
                return Err(ArrowError::ParseError(format!(
                    "Unsupported message header type in IPC stream: '{:?}'",
                    x
                )));
            }
        };

        Ok(ipc_message)
    }

    pub fn read_record_batch(
        &mut self,
        message: Message,
        batch: RecordBatch,
        schema: SchemaRef,
        projection: Option<&[usize]>,
        dictionaries: &mut HashMap<i64, ArrayRef>,
        skip_validation: arrow_data::UnsafeFlag,
    ) -> Result<Option<arrow_array::RecordBatch>, ArrowError> {
        // read the block that makes up the record batch into a buffer
        let mut buf = MutableBuffer::from_len_zeroed(message.bodyLength() as usize);
        self.reader.read_exact(&mut buf)?;

        RecordBatchDecoder::try_new(
            &buf.into(),
            batch,
            schema,
            &dictionaries,
            &message.version(),
        )?
        .with_projection(projection)
        .with_require_alignment(false)
        .with_skip_validation(skip_validation)
        .read_record_batch()
        .map(Some)
    }

    fn read_meta_size(&mut self) -> Result<i32, ArrowError> {
        let mut meta_size: [u8; 4] = [0; 4];
        self.reader.read_exact(&mut meta_size)?;
        let meta_len = {
            // If a continuation marker is encountered, skip over it and read
            // the size from the next four bytes.
            if meta_size == CONTINUATION_MARKER {
                self.reader.read_exact(&mut meta_size)?;
            }

            // Handle less than 0?
            i32::from_le_bytes(meta_size)
        };

        Ok(meta_len)
    }
}
